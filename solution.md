# Решение за X место
Прежде всего, мы очень рады быть частью такого глубокого и интересного конкурса, огромное спасибо организаторам за поддержку и всем конкурсантам, которые самоотверженно делились своими знаниями и инсайтами.

Большое спасибо моей замечательной команде QuData в лице [@kerrit](https://www.kaggle.com/kerrit)! Мы находимся и работаем в Украине и хотим поблагодарить всех, кто сейчас поддерживает народ Украины!

## Описание решения

Решение представляет собой библиотеку из нескольких стратегий для различных стадий игры и действующих юнитов, а также некоторых вспомогательных функций.
Каждая стратегия - это набор правил, на основе которых строится поведение роботов и фабрик.

В основе решения лежит класс **DefaultStrategy** из файла basic.py. Он имеет набор обязательных методов для реализации полноценной стратегии игры, в частности:
* *getBid(...)* - выбор ставки
* *getSpawnPos(...)* - выбор позиции фабрики
* *getActions(...)* - определений действий для фабрик и роботов

Внутри класса **DefaultStrategy** может быть реализована полноценная стратегия.

Далее стратегия **DefaultStrategy** разбивается на две группы **Early** и **Game**.

### Early стратегии

**Early** стратегии - это стратегии фазы расстановки фабрик.
Каждая из стратегий имеет набор обязательных методов для реализиции стратегии для фазы игры, в частности:
* *getBid(...)* - выбор ставки
* *getSpawnPos(...)* - выбор позиции фабрики

Всего было реализовано 6 стратегий, распологаемых в сответствующих файлах.
* *default* - Базовая стратегия библиотеки расстановки фабрик. Позиция для фабрики выбирается случайно на основе ранее составленной матрицы весов. Подробный алгоритм составления матрицы весов описан [тут](TODO).
* *from_kaggle_strategy* - Эта стратегия является расширением *default*. В стратегии для расчёта весов используются алгоритмы из ноутбука [@istinetz](https://www.kaggle.com/code/istinetz/picking-a-good-starting-location).
* *best_strategy* - Данная стратегия является улучшением *default* в части выбора позиции. Самым важным изменением было устранение случайности при выборе позиции. В данной стратегии позиция фабрики выбирается на основе количества щебня в квадрате 3x3 вокруг точки. Кроме этого были немного изменены коэффициенты матрицы весов.
* *single_strategy* - Стратегия для тестового обучения RL модели. Основанна на *best_strategy*. Отличительной особенностью является то, что в стратегии выставляется только одна фабрика.
* *new_from_kaggle* - Стратегия использующая алгоритмы из ноутбука [@istinetz](https://www.kaggle.com/code/istinetz/picking-a-good-starting-location). Отличительной особенностью является то, что в качестве весов используется отношение общего количества ячеек к "плохим" (> 25) ячейкам.
* *next_generation* - Последняя и, по тестам, лучшая стратегия из реализованных в библиотеке. В стратегии расчитываются отдельные матрицы весов для льда и руды, а при выборе позиции фабрики учитывается количество щебня в кварате 7x7 вокруг точки. Кроме этого, в случае, если все лучшие позиции, примыкающие к льду, заняты, матрица весов для льда пересчитывается.

### Game стратегии

**Game** стратегии - это стратегии фазы игры, которые разбиваются на две группы **Factory** и **Robot**.
Каждая из стратегий имеет набор обязательных методов для реализиции стратегии для фазы игры, в частности:
* *getFactoryActions(...)* - вернуть действия для фабрик
* *getRobotActions(...)* - вернуть действия для роботов

#### Factory стратегии

**Factory** стратегии - это стратегии работы фабрик.

Всего было реализовано 6 стратегий, распологаемых в сответствующих файлах.
* *default* - Базовая стратегия для фабрик. В случае наличия ресурсов создаёт 1 тяжёлого и до 3 лёгких роботов, а после 700 хода начинает выращивать лишайник, резервируя 1000-step воды.
* *mean_water* - Улучшенная *default* стратегия. В стратегии для вычисления шага высаживания лишайника используется среднее изменение воды за шаг.
* *for_best* - Новая стратегия работы фабрики для *best_strategy*. В стратегии создаётся до 20 лёгких роботов, при этом количество роботов вычисляется по формуле min(max(round(step-self.max_to)/self.l_ts*self.l_max, self.l_min), self.l_max) TODO. Количество тяжёлых роботов не ограничено. Для расчёта времени высаживания лишайника также используется коэффициент увеличения стоимости лишайника за шаг.
* *for_best_v2* - Ответвление стратегии *for_best*. В стратегии добавлен учёт лишайника, который мы, потенциально, вырастим через $min(300, 1000-step)$ шагов.
* *no_limit* - Улучшение стратегии *for_best*. В стратегии увеличен порог лёгких роботов до 100 на каждую фабрику, а количество тяжёлых ограничено 6.
* *no_limit_v2* - Ответвление стратегии *no_limit*. В стратегии добавлен учёт лишайника, который мы, потенциально, вырастим через $min(300, 1000-step)$ шагов.

#### Robot стратегии

**Robot** стратегии - это стратегии поведения роботов.
Стратегии роботов являются наиболее сложными среди других стратегий и используют больше вспомогательных средств.

##### Общие сведения о задачах

В общем смысле поведение роботов в стратегиях обуславливается **задачей**.

**Задача** - это набор алгоритмов для реализации поведения роботов. Изначально в библиотеке существало две задачи MINER (добывает лёд) и CLEANER (убирает щебень). Позже этот перечень был расширен.

В обязанности робота добытчика входило: 
* найти позицию льда, 
* построить маршрут, 
* добавить действия копания, если робот находится на ресурсе, 
* вернуться на фабрику, если не можем больше ничего выкопать (зкончилась энергия).

В обязанности робота уборщика входило: 
* найти ближайший щебень, 
* построить маршрут, 
* добавить действия копания, если робот находится на щебне, 
* вернуться на фабрику, если закончилась энергия.

##### Описание стратегий

Для реализации алгоритмов задач роботов использовались некоторые вспомогательные средства. Первым из таких являеются **Eyes**.

**Eyes** - Это класс, хранящий в себе массивы состояния игры, а также позволяющий удобно производить различные операции с ними.
Изначально данные **Eyes** обновлялись внутри **Game** стратегии на каждом шаге. В более поздних версиях библиотеки для контроля состояния игры был реализован класс **DataController**.
Всего в Eyes использовалось N матриц:
* factories - Расположение фабрик противника. В матрице вносились все занятые фабрикой противника клетки.
* units(версия 1) - Расположение союзных юнитов.
* units(версия 2) - Расположение союзных юнитов или их следующий ход.
* units(версия 3) - Расположение союзных юнитов или их следующий ход. В случае кллизии значения складываются.
* u_move - Возможные ходы сюзника. В более поздних версиях вместо 1 использовался тип робота.
* e_move - Возможные ходы противника. В более поздних версиях вместо 1 использовался тип робота.
* u_energy - Энергия союзника, распределённая по возможным ходам.
* e_energy(версия 1) - Энергия противника, распределённая по возможным ходам.
* e_energy(версия 2) - Энергия противника, распределённая по возможным ходам. В случае коллизии значения складываются.
* e_energy(версия 3) - Энергия противника, распределённая по возможным ходам. В случае коллизии значения складываются. В позиции робота - 0.
* e_lichen - Расположение лишайника противника.

Используя только **Eyes** были реализованы следующие 3 стратегии.
* *default* - Базовая стратегия поведения роботов, суть которой сводится к тому, что роботы выполняли только задачи MINER и CLEANER. Роботы учитывали положение союзников при построения маршрута, тем самым избегали наезда на союзников. Задача назначалась следующим образом: тяжёлые роботы всегда MINER, лёгким до 500 хода назначалась задача MINER после 500 - CLEANER. В стратегии использовались матрицы Eyes: factories и units(1).
* *cautious* - Убегающая стратегия для роботов. В стратегии был реализован механизм убегания роботов. Суть механизма состояла в том, что, если разница e_energy(1)-u_energy > 0, значит нас могут задавить и робот возвращался на базу. В стратегии использовались матрицы Eyes: factories, units(1), e_energy(1), u_energy. Также эта стратегия была реализована как отдельная GameStrategy для примера того, что можно использовать любой удобный подход при реализации стратегия.
* *curious* - Догоняющая стратегия. Это улучшенная *cautious* стратегия. В стратеги был добавлен показатель преследования, который отвечал за то, сколько шагов робот будет преследовать противника, чтобы задавить. В стратегии использовались матрицы Eyes: factories, units(2), e_energy(2), u_energy, u_move. Кроме этого матрицы u_energy и u_move были индивидуальными для каждого робота, что исключило некоторые проблемы. 

Следующим шагом был реализован вспомогательный класс **Observer**, который занимался распределение задач роботам. Количество задач было расширено до: MINER, CLEANER, RETURN(идти на базу), JOBLESS(безработный), WARRION(давит противников), LEAVER(убегает), RECHARGE(заряжается). Это способствовало более гибкому управлению роботами.

Используя **Eyes** и **Observer** были реализованы следующие 3 стратегии.
* *optimised* - Улучшенная и оптимизированная *curious* стратегия роботов с учётом новых задач. В стратегии использовались матрицы Eyes: factories, units(2), e_energy(2), u_energy, u_move.
* *fixed* - Исправленная версия стратегии *optimised*. В стратегии была добавлена задача RECHARGE(заряжается).В стратегии использовались матрицы Eyes: factories, units(3), e_energy(3), u_energy, u_move.

Последним вспомогательным средством является класс **TaskManager**. В задачи класса входит более глубокое указание задач робота. На классе **Observer** остались только функции наблюдения за средой и информировании о том, что задачу роботу нужно сменить. Кроме этого были определены новые задачи: WALKER(отойти, если на нас едет союзник), CARRIER (убирает щебень до ближайшего ресурса), ENERGIZER(заряжает роботов, примыкающих к фабрике), DESTROYER(уничтожает вражеский лишайник), разделена задача MINER на ICE_MINER и ORE_MINER, а сами задачи были разделены на постоянные (ICE_MINER, CARRIER ...) и одноразовые(WALKER, LEAVER ...).
Постоянные задачи закрепляются за роботом и переопределяются когда у робота закончилась очередь, одноразовые определяются только при возникновении определённого события (на нас едет враг и он нас задавит(LEAVER) или союзник(WALKER), у нас закончилась энергия(RECHARGE)).

Используя все вспомогательные средства была реализована следующая стратегия поведения роботов:
* *next_generation* - Эта стратегия полностью реализовывала все задачи роботов, кроме этого были исправлены многие ошибки. В стратегии, благодаря **TaskManager** регулировалось количество роботов на задачах, в частности, задача ICE_MINER не назначалась трём роботам, если рядом с нами только два льда и т.д. Кроме этого контролировалось количество роботов ENERGIZER, чтобы их было не больше чем ICE_MINER. CARRIER чистил путь к ресурсу только в первые 50 ходов, а дальше шёл добывать ресурс. По задаче ICE_MINER отдавался приоритет тяжёлым роботам, если таких небыло, то их место занимали лёгкие. Контролировалось количество CLEANER. Если расстояние до ближайшего щебня > 14, то роботы становились DESTROYER или WARRIOR, если лишайника не было у противника. Кроме этого общее количество роботов MINER зависило от текущего шага.


##### Вспомогательные функции

Для поиска пути ботов был реализован класс **Path**. Более подробный алгоритм поиска пути описан [здесь](TODO)
Отличительно и неожиданно полезной фичей поиска пути стал добавленный режим окна. Суть его сводился к тому, что мы ищем путь не на всей карте, а на вырезанной области с минимальным размером 5x5. В углах этой области распологались начальная точка маршрута и конечная. Пример режима окна ниже на картинке.

image

## Ссылки на решение

* [Здесь](https://github.com/BooCreator/Lux-AI-Season-2-Strategy-Library) можно посмотреть полный код решения
* [Здесь](https://github.com/BooCreator/Lux-AI-Season-2-Strategy-Library/tree/main/strategy) находится реализация стратегий решения
* [Здесь](https://github.com/BooCreator/Lux-AI-Season-2-Strategy-Library/tree/main/bots) находится реализация последних загруженных ботов
* [Здесь](https://github.com/BooCreator/Lux-AI-Season-2-Strategy-Library/tree/main/strategy/kits) находится реализация всех вспомогательных средств и классов